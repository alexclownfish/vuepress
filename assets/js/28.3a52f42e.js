(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{552:function(t,e,r){"use strict";r.r(e);var o=r(8),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"k8s-nodeport、port、targetport、hostport详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#k8s-nodeport、port、targetport、hostport详解"}},[t._v("#")]),t._v(" K8s nodePort、port、targetPort、hostPort详解")]),t._v(" "),r("h2",{attrs:{id:"_1-nodeport"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-nodeport"}},[t._v("#")]),t._v(" 1. nodePort")]),t._v(" "),r("p",[t._v("外部流量访问k8s集群中service入口的一种方式（另一种方式是LoadBalancer），即nodeIP:nodePort是提供给外部流量访问k8s集群中service的入口。比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的type=NodePort，nodePort=30001。其他用户就可以通过浏览器http://node:30001访问到该web服务。而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。")]),t._v(" "),r("h2",{attrs:{id:"_2-port"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-port"}},[t._v("#")]),t._v(" 2. port")]),t._v(" "),r("p",[t._v("k8s集群内部服务之间访问service的入口。即clusterIP:port是service暴露在clusterIP上的端口。mysql容器暴露了3306端口，集群内其他容器通过33306端口访问mysql服务，但是外部流量不能访问mysql服务，因为mysql服务没有配置NodePort。对应的service.yaml如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("apiVersion: v1\nkind: Service\nmetadata:\n name: mysql-service\nspec:\n ports:\n - port: 33306\n   targetPort: 3306\n selector:\n  name: mysql-pod\n")])])]),r("h2",{attrs:{id:"_3-targetport"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-targetport"}},[t._v("#")]),t._v(" 3.targetPort")]),t._v(" "),r("p",[t._v("容器的端口（最终的流量端口）。targetPort是pod上的端口，从port和nodePort上来的流量，经过kube-proxy流入到后端pod的targetPort上，最后进入容器。\n制作容器时暴露的端口一致（使用DockerFile中的EXPOSE），例如官方的nginx（参考DockerFile）暴露80端口。 对应的service.yaml如下")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("apiVersion: v1\nkind: Service\nmetadata:\n name: nginx-service\nspec:\n type: NodePort         // 有配置NodePort，外部流量可访问k8s中的服务\n ports:\n - port: 30080          // 服务访问端口\n   targetPort: 80       // 容器端口\n   nodePort: 30001      // NodePort\n selector:\n  name: nginx-pod\n")])])]),r("h2",{attrs:{id:"_4-hostport"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-hostport"}},[t._v("#")]),t._v(" 4.hostPort")]),t._v(" "),r("p",[t._v("这是一种直接定义Pod网络的方式。hostPort是直接将容器的端口与所调度的节点上的端口路由，这样用户就可以通过宿主机的IP加上来访问Pod了，如:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("apiVersion: v1\nkind: Pod\nmetadata:\n  name: influxdb\nspec:\n  containers:\n    - name: influxdb\n      image: influxdb\n      ports:\n        - containerPort: 8086\n          hostPort: 8086\n")])])]),r("p",[t._v("这样做有个缺点，因为Pod重新调度的时候该Pod被调度到的宿主机可能会变动，这样就变化了，用户必须自己维护一个Pod与所在宿主机的对应关系。\n使用了 hostPort 的容器只能调度到端口不冲突的 Node 上，除非有必要（比如运行一些系统级的 daemon 服务），不建议使用端口映射功能。如果需要对外暴露服务，建议使用 NodePort Service。")]),t._v(" "),r("h2",{attrs:{id:"_5-总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[t._v("#")]),t._v(" 5. 总结")]),t._v(" "),r("p",[t._v("总的来说，port和nodePort都是service的端口，前者暴露给k8s集群内部服务访问，后者暴露给k8s集群外部流量访问。从上两个端口过来的数据都需要经过反向代理kube-proxy，流入后端pod的targetPort上，最后到达pod内的容器。")])])}),[],!1,null,null,null);e.default=a.exports}}]);